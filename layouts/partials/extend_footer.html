<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>

<script>
  let shapes = [];
  let palette = [
    '#da532c1a', 
    '#da532c1a', 
    '#497cc921', 
    '#497cc921'
  ];
  let numShapes = 20; 

  function setup() {
    let canvas = createCanvas(windowWidth, windowHeight);
    canvas.position(0, 0);
    canvas.style('z-index', '-1');
    canvas.style('position', 'fixed');
    canvas.style('pointer-events', 'none');
    
    for (let i = 0; i < numShapes; i++) {
      shapes.push(new FloatingShape());
    }
  }

  function draw() {
    // 1. Detect PaperMod Dark Mode
    let isDark = document.body.classList.contains('dark');
    
    // 2. Set Background Color based on Mode
    if (isDark) {
      background(10, 10, 10); // Your requested RGB(10,10,10)
    } else {
      background(255); // White for Light Mode
    }
    
    // 3. Dynamic Grid Color
    // We adjust the grid stroke so it's visible in both modes
    if (isDark) {
      stroke('#b66c580d'); // Very faint white for dark mode
    } else {
      stroke('#b66c580d'); // Your original light mode grid color
    }
    
    strokeWeight(1);
    for (let x = 0; x < width; x += 50) line(x, 0, x, height);
    for (let y = 0; y < height; y += 50) line(0, y, width, y);

    for (let shape of shapes) {
      shape.move();
      shape.display();
    }
  }

  class FloatingShape {
    constructor() {
      this.x = random(width);
      this.y = random(height);
      
      // 1. 50/50 DISTRIBUTION LOGIC
      if (random() < 0.35) {
        this.type = 3; // Pentagon (the hexagon-style wiggler)
      } else {
        this.type = floor(random(0, 3)); // 0=Circle, 1=Line, 2=Square
      }

      // 2. SLOWER VELOCITY FOR PENTAGONS
      let speedScale = (this.type === 3) ? 0.1 : 0.4; 
      this.vx = random(-speedScale, speedScale);
      this.vy = random(-speedScale, speedScale);

      this.angle = random(TWO_PI);
      this.rotSpeed = random(-0.01, 0.01);
      this.color = color(random(palette));
      
      let sizeBase = random(35, 40);
      let multiplier = random() > 0.8 ? 2.5 : 1; 
      this.size = sizeBase * multiplier;

      this.wiggleSeeds = [];
      for(let i=0; i<5; i++) this.wiggleSeeds.push(random(1000));
    }

    move() {
      this.x += this.vx;
      this.y += this.vy;
      this.angle += this.rotSpeed;

      // Wrap around edges
      if (this.x > width + this.size) this.x = -this.size;
      if (this.x < -this.size) this.x = width + this.size;
      if (this.y > height + this.size) this.y = -this.size;
      if (this.y < -this.size) this.y = height + this.size;
    }

    display() {
      push();
      translate(this.x, this.y);
      rotate(this.angle);
      noFill();
      stroke(this.color);
      strokeWeight(1.2);

      if (this.type === 0) {
        ellipse(0, 0, this.size);
      } 
      else if (this.type === 1) {
        line(-this.size/2, 0, this.size/2, 0);
      } 
      else if (this.type === 2) {
        rectMode(CENTER);
        rect(0, 0, this.size, this.size);
      } 
      else if (this.type === 3) {
        // 3. MUCH MORE WIGGLE
        let points = [];
        for (let i = 0; i < 5; i++) {
          let a = TWO_PI / 5 * i;
          // Increased '25' for more movement, increased '0.05' for faster vibration
          let wiggle = map(noise(this.wiggleSeeds[i] + frameCount * 0.015), 0, 1, -10, 10);
          let r = (this.size / 2) + wiggle;
          points.push({ x: cos(a) * r, y: sin(a) * r });
        }

        beginShape();
        for (let p of points) vertex(p.x, p.y);
        endShape(CLOSE);

        fill(this.color);
        for (let p of points) ellipse(p.x, p.y, 4, 4);
        noFill();
      }
      pop();
    }
  }

  function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>